{"componentChunkName":"component---src-templates-doc-template-js","path":"/en/docs/apidatabasemd","result":{"data":{"markdownRemark":{"frontmatter":{"id":"apidatabasemd","title":"Database"}},"allFile":{"edges":[{"node":{"relativeDirectory":"layout","childLayoutJson":{"layout":{"header":{"quick":"Quick Start","benchmarks":"Benchmarks","why":"Why Haystack","gui":"Admin","tutorials":"Tutorials","solution":"Scenarios","about":"About Haystack","doc":"Docs","blog":"Blog","try":"Try","loading":"Loading...","noresult":"No Result","tutorial":"Tutorial","search":"Search","bootcamp":"Bootcamp"}}}}}]}},"pageContext":{"locale":"en","old":"apidatabasemd","headings":[{"value":"Database","depth":1},{"value":"Base","depth":2},{"value":"class haystack.database.base.BaseDocumentStore()","depth":3},{"value":"Elasticsearch","depth":2},{"value":"class haystack.database.elasticsearch.ElasticsearchDocumentStore(host: str = 'localhost', port: int = 9200, username: str = '', password: str = '', index: str = 'document', searchfields: Unionstr, list = 'text', textfield: str = 'text', namefield: str = 'name', externalsourceidfield: str = 'externalsourceid', embeddingfield: Optionalstr = None, embeddingdim: Optionalint = None, custommapping: Optionaldict = None, excludedmetadata: Optionallist = None, faqquestionfield: Optionalstr = None, scheme: str = 'http', cacerts: bool = False, verifycerts: bool = True, createindex: bool = True)","depth":3},{"value":"Memory","depth":2},{"value":"class haystack.database.memory.InMemoryDocumentStore(embedding_field: Optionalstr = None)","depth":3},{"value":"SQL","depth":2},{"value":"class haystack.database.sql.Document(**kwargs)","depth":3},{"value":"class haystack.database.sql.DocumentTag(**kwargs)","depth":3},{"value":"class haystack.database.sql.ORMBase(**kwargs)","depth":3},{"value":"class haystack.database.sql.SQLDocumentStore(url: str = 'sqlite://')","depth":3},{"value":"class haystack.database.sql.Tag(**kwargs)","depth":3}],"fileAbsolutePath":"/home/markus/Documents/git/haystack-io/src/pages/docs/site/en/api/api/database.md","editPath":"api/api/database.rst","allMenus":[{"lang":"en","menuList":[{"id":"usage_haystack","title":"Usage","label1":"","label2":"","label3":"","order":0,"isMenu":true},{"id":"intromd","title":"What is Haystack","label1":"usage_haystack","label2":"","label3":"","order":0,"isMenu":null},{"id":"get_startedmd","title":"Get Started","label1":"usage_haystack","label2":"","label3":"","order":1,"isMenu":null},{"id":"databasemd","title":"Document Store","label1":"usage_haystack","label2":"","label3":"","order":2,"isMenu":null},{"id":"retrievermd","title":"Retriever","label1":"usage_haystack","label2":"","label3":"","order":3,"isMenu":null},{"id":"readermd","title":"Reader","label1":"usage_haystack","label2":"","label3":"","order":4,"isMenu":null},{"id":"domain_adaptionmd","title":"Domain Adaption","label1":"usage_haystack","label2":"","label3":"","order":5,"isMenu":null},{"id":"termsmd","title":"Glossary","label1":"usage_haystack","label2":"","label3":"","order":6,"isMenu":null},{"id":"tutorials_haystack","title":"Tutorials","label1":"","label2":"","label3":"","order":1,"isMenu":true},{"id":"tutorial1md","title":"Task: Question Answering for Game of Thrones","label1":"tutorials_haystack","label2":"","label3":"","order":0,"isMenu":null},{"id":"tutorial2md","title":"Fine-tuning a model on your own data","label1":"tutorials_haystack","label2":"","label3":"","order":1,"isMenu":null},{"id":"tutorial3md","title":"Task: Build a Question Answering pipeline without Elasticsearch","label1":"tutorials_haystack","label2":"","label3":"","order":2,"isMenu":null},{"id":"tutorial4md","title":"FAQ-Style QA: Utilizing existing FAQs for Question Answering","label1":"tutorials_haystack","label2":"","label3":"","order":3,"isMenu":null},{"id":"tutorial5md","title":"Evaluation","label1":"tutorials_haystack","label2":"","label3":"","order":4,"isMenu":null},{"id":"tutorial6md","title":"Better retrieval via Dense Passage Retrieval","label1":"tutorials_haystack","label2":"","label3":"","order":5,"isMenu":null},{"id":"api_haystack","title":"API","label1":"","label2":"","label3":"","order":2,"isMenu":true},{"id":"apidatabasemd","title":"Database","label1":"api_haystack","label2":"","label3":"","order":0,"isMenu":null},{"id":"apiretrievermd","title":"Retriever","label1":"api_haystack","label2":"","label3":"","order":1,"isMenu":null},{"id":"apireadermd","title":"Reader","label1":"api_haystack","label2":"api_haystack","label3":"","order":2,"isMenu":null},{"id":"apiindexingmd","title":"Indexing","label1":"api_haystack","label2":"","label3":"","order":3,"isMenu":null},{"id":"rest_apimd","title":"Rest API","label1":"api_haystack","label2":"","label3":"","order":4,"isMenu":null},{"id":"file_convertersmd","title":"File Converters","label1":"api_haystack","label2":"","label3":"","order":5,"isMenu":null}],"absolutePath":"/home/markus/Documents/git/haystack-io/src/pages/docs/site/en/menuStructure/menu.json"}],"newHtml":"<h1>Database</h1>\n<h2>Base</h2>\n<h3>class haystack.database.base.BaseDocumentStore()</h3>\n<p>Bases: <code>abc.ABC</code></p>\n<p>Base class for implementing Document Stores.</p>\n<h4>abstract write_documents(documents: List[dict])</h4>\n<p>Indexes documents for later queries.</p>\n<ul>\n<li>\n<p><strong>Parameters</strong></p>\n<p><strong>documents</strong> – List of dictionaries.\nDefault format: {“text”: “<the-actual-text>”}\nOptionally: Include meta data via {“text”: “<the-actual-text>”,\n“meta”:{“name”: “<some-document-name>, “author”: “somebody”, …}}\nIt can be used for filtering and is accessible in the responses of the Finder.</p>\n</li>\n<li>\n<p><strong>Returns</strong></p>\n<p>None</p>\n</li>\n</ul>\n<h2>Elasticsearch</h2>\n<h3>class haystack.database.elasticsearch.ElasticsearchDocumentStore(host: str = 'localhost', port: int = 9200, username: str = '', password: str = '', index: str = 'document', search<em>fields: Union[str, list] = 'text', text</em>field: str = 'text', name<em>field: str = 'name', external</em>source<em>id</em>field: str = 'external<em>source</em>id', embedding<em>field: Optional[str] = None, embedding</em>dim: Optional[int] = None, custom<em>mapping: Optional[dict] = None, excluded</em>meta<em>data: Optional[list] = None, faq</em>question<em>field: Optional[str] = None, scheme: str = 'http', ca</em>certs: bool = False, verify<em>certs: bool = True, create</em>index: bool = True)</h3>\n<p>Bases: <code>haystack.database.base.BaseDocumentStore</code></p>\n<h4>_<em>init__(host: str = 'localhost', port: int = 9200, username: str = '', password: str = '', index: str = 'document', search</em>fields: Union[str, list] = 'text', text<em>field: str = 'text', name</em>field: str = 'name', external<em>source</em>id<em>field: str = 'external</em>source<em>id', embedding</em>field: Optional[str] = None, embedding<em>dim: Optional[int] = None, custom</em>mapping: Optional[dict] = None, excluded<em>meta</em>data: Optional[list] = None, faq<em>question</em>field: Optional[str] = None, scheme: str = 'http', ca<em>certs: bool = False, verify</em>certs: bool = True, create_index: bool = True)</h4>\n<p>A DocumentStore using Elasticsearch to store and query the documents for our search.</p>\n<blockquote>\n<ul>\n<li>Keeps all the logic to store and query documents from Elastic, incl. mapping of fields, adding filters or boosts to your queries, and storing embeddings</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>You can either use an existing Elasticsearch index or create a new one via haystack</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>Retrievers operate on top of this DocumentStore to find the relevant documents for a query</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p><strong>Parameters</strong></p>\n<ul>\n<li><strong>host</strong> – url of elasticsearch</li>\n<li><strong>port</strong> – port of elasticsearch</li>\n<li><strong>username</strong> – username</li>\n<li><strong>password</strong> – password</li>\n<li><strong>index</strong> – Name of index in elasticsearch to use. If not existing yet, we will create one.</li>\n<li><strong>search_fields</strong> – Name of fields used by ElasticsearchRetriever to find matches in the docs to our incoming query (using elastic’s multi<em>match query), e.g. [“title”, “full</em>text”]</li>\n<li><strong>text_field</strong> – Name of field that might contain the answer and will therefore be passed to the Reader Model (e.g. “full_text”).\nIf no Reader is used (e.g. in FAQ-Style QA) the plain content of this field will just be returned.</li>\n<li><strong>name_field</strong> – Name of field that contains the title of the the doc</li>\n<li><strong>external<em>source</em>id_field</strong> – If you have an external id (= non-elasticsearch) that identifies your documents, you can specify it here.</li>\n<li><strong>embedding_field</strong> – Name of field containing an embedding vector (Only needed when using a dense retriever (e.g. DensePassageRetriever, EmbeddingRetriever) on top)</li>\n<li><strong>embedding_dim</strong> – Dimensionality of embedding vector (Only needed when using a dense retriever (e.g. DensePassageRetriever, EmbeddingRetriever) on top)</li>\n<li><strong>custom_mapping</strong> – If you want to use your own custom mapping for creating a new index in Elasticsearch, you can supply it here as a dictionary.</li>\n<li><strong>excluded<em>meta</em>data</strong> – Name of fields in Elasticsearch that should not be returned (e.g. [field<em>one, field</em>two]).\nHelpful if you have fields with long, irrelevant content that you don’t want to display in results (e.g. embedding vectors).</li>\n<li><strong>scheme</strong> – ‘https’ or ‘http’, protocol used to connect to your elasticsearch instance</li>\n<li><strong>ca_certs</strong> – Root certificates for SSL</li>\n<li><strong>verify_certs</strong> – Whether to be strict about ca certificates</li>\n<li><strong>create_index</strong> – Whether to try creating a new index (If the index of that name is already existing, we will just continue in any case)</li>\n</ul>\n</li>\n</ul>\n<h4>add<em>eval</em>data(filename: str, doc<em>index: str = 'eval</em>document', label_index: str = 'feedback')</h4>\n<p>Adds a SQuAD-formatted file to the DocumentStore in order to be able to perform evaluation on it.</p>\n<ul>\n<li>\n<p><strong>Parameters</strong></p>\n<ul>\n<li><strong>filename</strong> (<em>str</em>) – Name of the file containing evaluation data</li>\n<li><strong>doc_index</strong> (<em>str</em>) – Elasticsearch index where evaluation documents should be stored</li>\n<li><strong>label_index</strong> (<em>str</em>) – Elasticsearch index where labeled questions should be stored</li>\n</ul>\n</li>\n</ul>\n<h4>update_embeddings(retriever)</h4>\n<p>Updates the embeddings in the the document store using the encoding model specified in the retriever.\nThis can be useful if want to add or change the embeddings for your documents (e.g. after changing the retriever config).</p>\n<ul>\n<li>\n<p><strong>Parameters</strong></p>\n<p><strong>retriever</strong> – Retriever</p>\n</li>\n<li>\n<p><strong>Returns</strong></p>\n<p>None</p>\n</li>\n</ul>\n<h4>write_documents(documents: List[dict])</h4>\n<p>Indexes documents for later queries in Elasticsearch.</p>\n<ul>\n<li>\n<p><strong>Parameters</strong></p>\n<p><strong>documents</strong> – List of dictionaries.\nDefault format: {“text”: “<the-actual-text>”}\nOptionally: Include meta data via {“text”: “<the-actual-text>”,\n“meta”:{“name”: “<some-document-name>, “author”: “somebody”, …}}\nIt can be used for filtering and is accessible in the responses of the Finder.\nAdvanced: If you are using your own Elasticsearch mapping, the key names in the dictionary\nshould be changed to what you have set for self.text<em>field and self.name</em>field .</p>\n</li>\n<li>\n<p><strong>Returns</strong></p>\n<p>None</p>\n</li>\n</ul>\n<h2>Memory</h2>\n<h3>class haystack.database.memory.InMemoryDocumentStore(embedding_field: Optional[str] = None)</h3>\n<p>Bases: <code>haystack.database.base.BaseDocumentStore</code></p>\n<p>In-memory document store</p>\n<h4>_<em>init__(embedding</em>field: Optional[str] = None)</h4>\n<p>Initialize self.  See help(type(self)) for accurate signature.</p>\n<h4>get<em>all</em>documents()</h4>\n<h4>get<em>document</em>by_id(id: str)</h4>\n<h4>get<em>document</em>count()</h4>\n<h4>get<em>document</em>ids<em>by</em>tags(tags: Union[List[Dict[str, Union[str, List[str]]]], Dict[str, Union[str, List[str]]]])</h4>\n<p>The format for the dict is {“tag-1”: “value-1”, “tag-2”: “value-2” …}\nThe format for the dict is {“tag-1”: [“value-1”,”value-2”], “tag-2”: [“value-3]” …}</p>\n<h4>index(: Optional[str])</h4>\n<h4>query<em>by</em>embedding(query<em>emb: List[float], filters: Optional[dict] = None, top</em>k: int = 10, index: Optional[str] = None)</h4>\n<h4>update_embeddings(retriever)</h4>\n<p>Updates the embeddings in the the document store using the encoding model specified in the retriever.\nThis can be useful if want to add or change the embeddings for your documents (e.g. after changing the retriever config).</p>\n<ul>\n<li>\n<p><strong>Parameters</strong></p>\n<p><strong>retriever</strong> – Retriever</p>\n</li>\n<li>\n<p><strong>Returns</strong></p>\n<p>None</p>\n</li>\n</ul>\n<h4>write_documents(documents: List[dict])</h4>\n<p>Indexes documents for later queries.</p>\n<ul>\n<li>\n<p><strong>Parameters</strong></p>\n<p><strong>documents</strong> – List of dictionaries in the format {“text”: “<the-actual-text>”}.\nOptionally, you can also supply “tags”: [“one-tag”, “another-one”]\nor additional meta data via “meta”: {“name”: “<some-document-name>, “author”: “someone”, “url”:”some-url” …}</p>\n</li>\n<li>\n<p><strong>Returns</strong></p>\n<p>None</p>\n</li>\n</ul>\n<h2>SQL</h2>\n<h3>class haystack.database.sql.Document(**kwargs)</h3>\n<p>Bases: <code>haystack.database.sql.ORMBase</code></p>\n<h4>__init__(**kwargs)</h4>\n<p>A simple constructor that allows initialization from kwargs.</p>\n<p>Sets attributes on the constructed instance using the names and\nvalues in <code>kwargs</code>.</p>\n<p>Only keys that are present as\nattributes of the instance’s class are allowed. These could be,\nfor example, any mapped columns or relationships.</p>\n<h4>created()</h4>\n<h4>id()</h4>\n<h4>meta_data()</h4>\n<h4>tags()</h4>\n<h4>text()</h4>\n<h4>updated()</h4>\n<h3>class haystack.database.sql.DocumentTag(**kwargs)</h3>\n<p>Bases: <code>haystack.database.sql.ORMBase</code></p>\n<h4>__init__(**kwargs)</h4>\n<p>A simple constructor that allows initialization from kwargs.</p>\n<p>Sets attributes on the constructed instance using the names and\nvalues in <code>kwargs</code>.</p>\n<p>Only keys that are present as\nattributes of the instance’s class are allowed. These could be,\nfor example, any mapped columns or relationships.</p>\n<h4>created()</h4>\n<h4>document_id()</h4>\n<h4>id()</h4>\n<h4>tag_id()</h4>\n<h4>updated()</h4>\n<h3>class haystack.database.sql.ORMBase(**kwargs)</h3>\n<p>Bases: <code>sqlalchemy.ext.declarative.api.Base</code></p>\n<h4>created( = Column(None, DateTime(), table=None, server<em>default=DefaultClause(&#x3C;sqlalchemy.sql.functions.now at 0x7f3ceabd2970; now>, for</em>update=False)))</h4>\n<h4>id( = Column(None, Integer(), table=None, primary_key=True, nullable=False))</h4>\n<h4>updated( = Column(None, DateTime(), table=None, server<em>default=DefaultClause(&#x3C;sqlalchemy.sql.functions.now at 0x7f3ce9fd52b0; now>, for</em>update=False)))</h4>\n<h3>class haystack.database.sql.SQLDocumentStore(url: str = 'sqlite://')</h3>\n<p>Bases: <code>haystack.database.base.BaseDocumentStore</code></p>\n<h4>__init__(url: str = 'sqlite://')</h4>\n<p>Initialize self.  See help(type(self)) for accurate signature.</p>\n<h4>get<em>all</em>documents()</h4>\n<h4>get<em>document</em>by_id(id: str)</h4>\n<h4>get<em>document</em>count()</h4>\n<h4>get<em>document</em>ids<em>by</em>tags(tags: Dict[str, Union[str, List]])</h4>\n<p>Get list of document ids that have tags from the given list of tags.</p>\n<ul>\n<li>\n<p><strong>Parameters</strong></p>\n<p><strong>tags</strong> – limit scope to documents having the given tags and their corresponding values.\nThe format for the dict is {“tag-1”: “value-1”, “tag-2”: “value-2” …}</p>\n</li>\n</ul>\n<h4>index(: Optional[str])</h4>\n<h4>query<em>by</em>embedding(query<em>emb: List[float], filters: Optional[dict] = None, top</em>k: int = 10, index: Optional[str] = None)</h4>\n<h4>write_documents(documents: List[dict])</h4>\n<p>Indexes documents for later queries.</p>\n<ul>\n<li>\n<p><strong>Parameters</strong></p>\n<p><strong>documents</strong> – List of dictionaries in the format {“text”: “<the-actual-text>”}.\nOptionally, you can also supply meta data via “meta”: {“author”: “someone”, “url”:”some-url” …}</p>\n</li>\n<li>\n<p><strong>Returns</strong></p>\n<p>None</p>\n</li>\n</ul>\n<h3>class haystack.database.sql.Tag(**kwargs)</h3>\n<p>Bases: <code>haystack.database.sql.ORMBase</code></p>\n<h4>__init__(**kwargs)</h4>\n<p>A simple constructor that allows initialization from kwargs.</p>\n<p>Sets attributes on the constructed instance using the names and\nvalues in <code>kwargs</code>.</p>\n<p>Only keys that are present as\nattributes of the instance’s class are allowed. These could be,\nfor example, any mapped columns or relationships.</p>\n<h4>created()</h4>\n<h4>documents()</h4>\n<h4>id()</h4>\n<h4>name()</h4>\n<h4>updated()</h4>\n<h4>value()</h4>"}},"staticQueryHashes":[]}